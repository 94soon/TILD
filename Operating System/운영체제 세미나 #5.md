# 파일시스템 

## 11.6 효율과 성능(Efficiency and Performance) 

* 다양한 블록 할당과 디렉토리 관리 기법을 살펴보았으므로 이들의 디스크 성능과 효휼적인 사용에 어떤 영향을 미치는지 살펴본다. 
* 디스크는 PC 구성요소 중에 가장 느리기 떄문에 시스템의 병목의 주 원인이 된다. 
	![](http://4.bp.blogspot.com/-aj2A1D_AM_o/VaROyqWFRgI/AAAAAAAAKI0/Co3KGHqHBPg/s1600/harddrive_ss-100004300-large.png)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
### 11.6.1 효율
* 디스크의 공간의 효율적인 사용은 사용 중인 디스크 할당 및 디렉토리 알고리즘에 의해 심각하게 좌우된다. 
	* 유닉스 inode 
		* 아이노드(inode)는 UFS와 같은 전통적인 유닉스 계통 파일 시스템에서 사용하는 자료구조이다. 아이노드는 정규 파일, 디렉터리 등 파일 시스템에 관한 정보를 가지고 있다. 
		* 파일들은 각자 1개의 아이노드를 가지고 있으며, 아이노드는 소유자 그룹, 접근 모드(읽기, 쓰기, 실행 권한), 파일 형태, 아이노드 숫자(inode number, i-number, 아이넘버) 등 해당 파일에 관한 정보를 가지고 있다. 파일시스템 내의 파일들은 고유한 아이노드 숫자를 통해 식별 가능하다.  
	* BSD UNIX 클러스터링 기법 
		* 내부 단편화를 허용하는 대신에 파일의 탐색과 파일 전송 성능을 향상시킨다. 
		* 내부 단편화를 줄이기 위해서 파일의 크기가 증가함에 따라 클러스터의 크기도 변화시킬 수 있다. 
		* 전부 채울 수 있는 경우에는 큰 클러스터를 사용하고, 작은 클러스터는 작은 파일들과 파일의 마지막 클러스터를 위해 이용된다. 

		
* 파일의 디렉토리 (또는 indoe) 항목 내에 저장되어야 하는 정보 
	* 파일의 '마지막 쓰기 시간' 
		* 사용자에게 정보를 제공하고, 또한 파일을 백업할지를 결정하는데 사용한다. 
	* 파일의 '마지막 접근 시간' 
		* 이 정보를 유지하게 되면 파일이 읽힐 때마다 디렉토리 구조의 필드가 갱신되어야 한다. 
		* 블록이 읽혀져 메모리로 들어오고, 해당 영역이 변경되고, 다시 디스크에 쓰여야 한다는 것을 의미한다. 
		* 이러한 요구조건은 자주 접근되는 파일의 경우 비효휼적이기 때문에 파일 시스템을 설계할 때 성능비용과 이득을 따져봐야 한다. 

		
* 변화하는 기술의 대비 
	* FAT32와 NTFS  
		* FAT16의 제한을 풀기 위해 만든 파일시스템. 클러스터 번호를 32비트로 저장하고 클러스터의 크기가 512바이트에서 4KB까지 지원하기 때문에 지원하는 디스크 크기의 물리적인 한계는 16TB이다.(논리 파티션은 8TB가 한계, 외부 파티션 관리 프로그램을 사용할 경우 2TB가 한계, 윈도우에서는 의도적으로 32GB까지만 지원.) 하지만 파일 하나의 크기가 최대 4GB까지밖에 지원을 하지 못한다.
		![](http://cfile9.uf.tistory.com/image/23547C4257A71EBB2E72AA)
		
		* NTFS는 마이크로소프트 OS인 윈도우즈의 파일 시스템이다. MS-DOS와 이전 버전의 윈도에서 쓰인 마이크로소프트의 이전 FAT 파일 시스템을 개선하여 만든 새로운 파일 시스템이다. FAT시스템에 비해 몇 가지 개선사항이 있는데, 메타데이터의 지원, 고급 데이터 구조의 사용으로 인한 성능 개선, 신뢰성, 추가 확장 기능을 더한 디스크 공간 활용을 들 수 있다.
		*  Windows NT 3.1이 발매된 1993년 당시 획기적인 파일시스템이었지만 현재는 더 좋은 파일시스템이 많이 나왔기 때문에 ReFS를 준비중에 있다. 

### 11.6.2 성능 
* 기본적인 파일 시스템 알고리즘이 결정된 후라도, 여전히 시스템 성능을 향상시킬 수 있는 방법들이 있다. 
* 13장에서 살펴볼 디스크 컨트롤러들은 한 트랙의 내용을 전부 저장할 수 있을 만큼의 충분한 크기의 온보드 캐시를 가지고 있다. 
* 일단 탐색이 디스크 헤드를 원하는 트랙으로 가져가면 그 트럭 전체를 디스크 캐시로 읽어드리고, 디스크 컨트롤러는 요청한 섹터를 OS로 전달한다. 

* 페이지 캐시 
	* 가상 메모리 기법을 사용하여 파일 데이터를 파일 시스템 지향의 블록이 아니라 페이지로 캐시한다. 
	* 이는 상당히 효율적인 방법으로 솔라리스, 윈도우 2000, NT, XP를 포함한 다수의 시스템이 사용하고 있으며 이 기법을 _'통합 가상 메모리'_ 라고 한다.   

	
* 통합 버퍼 캐시 
	* 파일을 열고 접근하기 위해서는 메모리 맵핑과 시스템 호출 2가지 대안이 있다. 
	* read(), write() 시스템 호출은 버퍼 캐시를 통과하게 될 것이고 메모리 맵핑은 페이지 캐시와 버퍼 캐시 두 가지를 사용해야 한다. 
	* 가상 메모리 시스템은 버퍼 캐시와 인터페이스할 수 없기 때문에 버퍼 캐시에 있는 파일의 내용을 페이지 캐시로 복사해야 하는데 이를 이중 캐싱이라고 한다. 
	* 이는 메모리 낭비일 뿐 아니라, 시스템 메모리 내에서 추가의 데이터 이동으로 인해 상단한 CPU I/O 사이클을 낭비하게 된다. 
	* 때문에 통합 버퍼 캐시를 지원함으로서 이중 캐싱을 피하게 하고, 가상 메모리 시스템 데이터를 관리할 수 있도록 한다. 
	![](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter12/12_12_UnifiedBufferCache.jpg)
   
   
* 파일 시스템 쓰기 연산이 동기적인가? 비동기적인가? 
	* 동기식 쓰기
		* 디스크 서브시스템이 요청을 받은 순서대로 이루어지며, 쓰기가 버퍼에 저장되지 않는다. 
		* 따라서 호출 루틴은 데이터가 디스크 드라이브에 쓰인 후에나 실행할 수 있다. 

	* 비동기식 쓰기 
		* 데이터를 캐시에 저장하고 호출자에게 제어를 돌려준다. 
		* 거의 대부분의 시간이 비동기식 쓰기에 사용된다.
		* 단, 운영체제는 흔히 open() 시스템 호출에 쓰기 작업은 동기식으로 실행할 것을 요청하는 플래그를 포함시키기도 한다. 

* 일부 시스템에서는 파일의 접근 타입에 따라 다른 교체 알고리즘을 사용함으로써 페이지 캐시를 최적화 한다. 
* 순차적으로 읽히거나 쓰이는 파일은 LRU 순서에 따라 교체되어서는 안된다. 
	* 바로-제거 
		* 다음 페이지가 요청되자마자 바로 버퍼에서 사용이 끝난 페이지를 제거하는 것을 말한다.  
	* 미리-읽기    
		* 요구된 페이지와 몇 개의 뒤이은 페이지를 캐싱하는 것을 의미한다. 

* 이러한 페이지들은 현재 페이지가 처리된 후에 요정될 가능성이 높다. 이들 페이지를 한 번의 전송으로 디스크에 가져와 캐싱함으로써 상당한 시간을 단축할 수 있다.


### 11.7 복구 
* 일관성 검사 
	* 오염의 원인이 무엇이든 파일 시스템은 문제를 검출하고 교정할 수 있어야 한다. 
	* 검출을 위해서는 시스템의 메타데터에 대한 검사를 통해 확인하는데 몇분에서 몇 시간이 소요되며 시스템이 부트 될 때마다 실행되어야 한다. 
	* 따라서 메타데이터를 변경하려고 할 때 상태 비트는 기록할 수 있게 하고 일관성 검사기를 통하여 데이터와 디스크와 데이터 블록을 비교하고 불일치가 발견되면 정정하도록 시도한다.  
	* UNIX 시스템에는 fsck, 윈도우에는 chdisk 등이 있다. 
	
* 로그 구조 파일 시스템 
	* 일관성 검사 기법을 사용하면 시스템 구조가 깨질 수 있고, 그 경우 복구 시에 수리 가능하다. 
	* 그러나 이 방법에 여러 문제들 중 하나가 깨진 일관성을 복구하지 못해 파일이나 디렉토리가 잃게 되는 현상이다. 
	![](http://forum.falinux.com/zbxe/files/attach/images/583/193/532/figure1%5B1%5D.gif)
	
	* 로그 구조 파일 시스템은 파일 시스템을 새 데이타와 파일 시스템 메타데이타를 로그의 헤드에 쓴 순화 로그로 여기며 여유 공간은 끝에서부터 사용된다.
	* 이렇게 하면 로그에 데이타가 두번 이상 표시될 수도 있지만 로그는 시간에 따라 정렬되기 때문에 가장 최근의 데이타가 활성 데이타로 표시된다.
	* 한 가지 중요한 장점으로는 시스템이 파손되었을 때 복구하는 기능을 들 수 있으며 Log-structured 방식을 사용하면 이 기능이 더 단순해진다.	
	* 또 다른 장점은 기본 스토리지 시스템을 사용하여 성능을 개선할 수 있다는 점이다. 순차적으로 디스크에 쓰는 동작은 무작위로 I/O에 쓰는 동작보다 훨씬 더 빠르다. 쓰기 동작은 모두 순차적으로 행해지기 때문에 찾기에 대한 부담이 제거되고 결과적으로 디스크 I/O 속도가 빨라져 파일 시스템의 속도가 개선된다. 
	
* 다른 해결 방안들 

	* 일관성 검사 이외에도 Network Appliance의 WAFL 파일 시스템과 Sun의 ZFS 파일 시스템이 채택되었다. 
	* 이 시스템들은 옛 데이터를 개 데이터로 절대 덮어 쓰지 않는다. 오히려 트랜젝션은 모든 데이터와 메타데이터 변경을 새로운 블럭에 기록한다.  
	* 트랜제잭션이 완료되면 이 블록들의 구 버전을 가리키고 있는 메타데이터 구조가 새로운 블록을 가리키도록 갱신하고 이후 파일 시스템은 구 포인터들과 옛 블록들은 제거하여 재사용 가능하게 만든다. 
	* 이러한 해결방안은 포인터 갱신이 자동적으로 일어난다면 일관성 검사가 필요없게 된다. 

* 백업과 복구   
	* 하드디스크는 종종 고장을 일으키고, 이러한 고장으로 손실된 데이터가 영월히 손실되지 않도록 보장해 줄 필요가 있다. 
	* 이 때문에 디스크의 내용을 다른 저장장치에 저장하는 벡업을 사용하며, 이를 사용하기 위한 시스템 프로그램이 사용될 수 있다. 

	
### 11.8 NFS (Network File System) 

* NFS는 컴퓨터 사용자가 원격지 컴퓨터에 있는 파일을 마치 자신의 컴퓨터에 있는 것처럼 검색하고, 마음대로 저장하거나 수정하도록 해주는 클라이언트/서버형 응용프로그램이다. 사용자 시스템에는 NFS 클라이언트가 있어야하며, 다른 컴퓨터 (원격지의 컴퓨터)에는 NFS 서버가 설치되어 있어야 한다. 또한, 둘 모두 TCP/IP 프로토콜이 설치되어 있어야 하는데, 왜냐하면, NFS 서버와 클라이언트가 파일을 보내거나 수정하는 프로그램으로 TCP/IP를 사용하기 때문이다 (그러나, 초기버전의 NFS에서는 TCP 대신에 UDP가 사용되기도 한다).

* NFS는 썬마이크로시스템즈에 의해 개발되었으며, 파일서버의 표준으로 정착되었다. 이 프로토콜은 컴퓨터들 간의 통신 방법으로서 RPC를 사용한다. 윈도우 95와 썬(Sun)의 Solstice Network Client와 같은 제품을 사용하는 일부 운영체계에 NFS를 설치할 수 있다.

* NFS를 이용하여, 사용자나 시스템관리자는 파일시스템의 전부 또는 일부를 설치할 수 있다. 설치된(액세스할 수 있도록 지정된) 파일시스템은 각 사용자들의 권한에 따라 개개의 파일을 액세스할 수 있게된다.

### 11.8.2 마운트 프로토콜 
* 서비스와 클라이언트 사이의 최초의 논리적 연결을 생성하기 위해서 사용된다. 
* 마운트 연산은 마운트될 원격 디렉토리의 이름과 이를 저장하는 서버 기계의 이름을 포함한다. 
* 마운트 요청은 적절한 RPC로 맵핑되고, 지명된 서버 기계 상에서 실행되는 마운트 서버로 전달된다. 

![](http://www.ipsure.com/images/wp-content/nfs-diagram.png)

* 서버는 export list를 유지하며, 이 목록은 마운트 할 수 있도록 하는 export하는 로컬 파일 시스템을 지정하고, 더불어 그것들을 마운트하도록 허가받은 머신의 이름을 함께 명시한다. 


### 11.8.3 NFS 프로토콜 
* NFS 프로토콜은 원격 파일 연산을 위한 원격 프로시저 호출의 집합을 제공한다. 
	* 디렉토리 내의 파일 검색 
	* 디렉토리 항목 집합 읽기 
	* 링크와 디렉토리들의 조작 
	* 파일 속성의 접근 
	* 파일 읽기와 쓰기 
* 이러한 프로시저는 원격으로 마운트된 디렉토리에 대한 파일 핸들이 구축되어야만 호출할 수 있다. 
* NFS 서비스의 주요 특징은 무상태성이다. 즉 서버는 하나의 접근과 다른 접근 사이에 클라이언트에 대한 정보를 유지하지 않는다. 
* 결론적으로 각각의 요구들은 적절한 동작을 위해서는 유일한 파일 식별자와 파일 내부의 절대적인 변위와 같은 모든 인자들을 제공해야 한다. P.548

### 11.8.4 경로 이름 변환 
* NFS에서의 결로 이름 변환은 /usr/local/dir1/fifle.txt와 같은 파일의 결로 이름을 파싱하는 것을 포함한다. 
* 이는 다음과 같은 세개의 엔트리로 나뉘어 진다. 
	* 경로 이름 변환은 경로를 구성오소 이름으로 분리 
	* 구성요소 이름과 디렉토리 vndoe의 모든 쌍에 대한 각각의 NFS 룩업을 호출을 실행함으로써 이루어진다. 
		* vnode에 대한 설명은 http://yebig.tistory.com/68 참조 
*	일단 마운트 포인트를 넘어가면, 모든 구성요소 룩업은 서버에 대한 개별 RPC를 유발한다. 
* 이는 많은 비용이 소모되는데 이를 사용하는 이유는 실행한 마운트에 의해 생겨난 자신의 논리적 이름 공간의 배치가 특유하기 때문이다. 

### 11.8.5 원격 연산 
* 파일의 열기와 닫기를 제외하면 파일 연산을 위한 정규 UNIX 시스템 호출들과 NFS의 RPC 프로토콜들 간에는 거의 1:1 대응 관계가 있다. 
* 원격 파일 연산은 대응되는 RPC로 직접 변환될 수 있다. 
* 실제로는 성능향상을 위해 버퍼링과 캐싱 기술을 사용한다. 
	* 파일 속성(inode-정보) 캐시와 파일-블록 캐시 2개의 캐시가 존재한다. 
	* 파일을 열 때, 커널은 캐시된 속성들을 다시 가져올지 또는 이전 것을 다시 사용할지 결정하기 위해 원격 서버를 검사한다. 
	* 캐시된 파일 블록들은 대응되는 캐시된 속성들이 최신 버전일 경우에만 사용한다. 
	* 서버로 부터 새로운 속성들이 도착될 때마다 캐시된 속성이 갱신되고 캐시된 속성들은 60초 후에 버려진다. 

	
### 11.9 WAFL 파일 시스템   
![](https://cdn.worldvectorlogo.com/logos/network-appliance.svg)

* Network Appliance에서 개발한 파일시스템으로 네트워크 파일서버에서 배타적으로 사용되고, 분산파일시스템으로 사용되기 위한 용도로 제작되었다. 
* 서버는 매우 대량의 무작위 읽기 요청 및 그보다 더 대용량의 무작의 쓰기 요청을 받을 수 있다. WAFL은 쓰기 연산을 위한 NVRAM 캐시를 갖는 파일 서버에서 사용된다. 

![](https://niktips.files.wordpress.com/2013/07/388375.jpg) 

* 무작위 입출력을 최적화 하기 위해 특정 아키텍처에서 사용되도록 설계되어있으며, 안정적인 저장장치 캐시의 이점을 활용하였다. 
* WAFL 파일 시스템은 루트 indoe를 기점으로 하는 블록들의 트리로 구성되어 있으며, 스냅샷을 작성하기 위해여 루트 indoe의 복사본을 생성한다. 
* 모든 파일 및 메타데이터의 갱신은 기존 블록을 덮어 쓰는 것이 아니라 새로운 블록에서 행해지므로 루트 inode는 이러한 쓰기 연산의 결과로 반영된 메타데이터와 데이터를 가리킨다. 
* 반면 스냅샷(기존의 루트 inode)은 업데이트 되어 있지 않기 때문에 여전히 기존의 데이터 블록들을 가리키고 있을 것이다. 
![](http://slideplayer.com/3997212/13/images/30/Example%3A+WAFL+Network+Appliance’s+WAFL+file+system+is+optimized+for+random+writes+on+network+file+servers..jpg) 

* 다수의 스냅샷이 동시에 존재할 수 있고, 따라서 스냅샷이 매 시간마다 그리고 매일 작성될 수 있다. 
* 이는 백업을 위해서도 상당히 유용하고, 테스트와 버전 관리를 위해서도 활용될 수 있다. WAFL의 스냅샷 기능은 블록에 대한 쓰기-시-복사(copy-on-write)조차 필요하지 않다는 점에서 매우 효휼적이다. 
* WAFL 파일 시스템 구현으로부터 자연스럽게 도출되는 또 다른 특징은 복제로써 네트워크를 통한 다른 시스템으로의 데이터의 중복과 동기화 기능이다. 