# 20.6 메모리 관리

Linux에서 메모리 관리는 두 부분으로 나누어 진다. 첫째는 물리메모리를 할당하고, 반납하는 것을 다룬다. 
둘째는 가상메모리를 다루는 일인데, 이는 실행 중인 프로세스들의 주소 공간으로 맵핑되는 메모리를 말한다. 
이 절에서 2부분에 대해 살펴보고, 새 프로그램의 적재 가능한 요소들이 exec() 시스템 호출에 따라 프로세스의 가상 메모리로 적재되는 기법을 알아본다. 

### 21.6.1 물리 메모리 관리 
* ZONE_DMA
* ZONE_NOMAL 
* ZONE_HIGHMEM 

* 이 ZONE들은 아키텍쳐에 따라 다르다. 
	* INTEL 80X86 아키텍쳐에서 ISA장치는 DMA를 사용하여 16MB보다 작은 메모리에 접근할 수 있음.
	* 이러한 시스템은 첫 16MB의 물리 메모리가 ZONE_DMA가 되며, ZONE_NOMAL은 CPU공간의 맵핑되는 물리 메모리를 구별한다. 
* zone은 대부분 메모리 요청을 위해 사용되며, DMA가 접근할수 있는 메모리를 제한하지 않는 시스템에서는 ZONE_NAMAL이 사용된다.
* ZONE_HIGHMEN은 커널공간에 맵핑되지 않는 물리 메모리를 의미한다. (32bit OS 메모리) 

* LINUX 커널에서 물리 메모리 관리자의 주 임무는 페이지 할당기 이다. 
* 각 zone은 할당기를 가지고 있으며, 이 할당기는 zone의 모든 물리 메모리 페이지들의 할당과 반납을 담당하고, 요청에 따라서는 물리적으로 연속된 페이지들의 영역을 할당해 줄 수 있다. 
* 할당기는 물리 페이지의 정보를 얻기 위해서 buddy 시스템을 사용하는데, 할당된 두 짝이 반납될 때마다 합쳐져서 더 큰 영역을 형성하고 (buddy heap) 그 영역은 다시 짝을 가지고 있어 합쳐져서 더 큰 영역(free region)을 형성할 수 있다. 
* 궁극적으로 리눅스 커널에서 모든 메모리 할당은 시스템 부팅 시 연속된 메모리 영역을 드라이버에 의해 정적으로 할당받거나, 페이지 할당기에 의해 동적으로 할당받는다. 하지만 커널은 메모리 관시 서브시스템을 가지고 있고 이들은 각자 풀을 관리하기 위해 페이지 할당기로 부터 메모리를 할당받는다. 

* 이 서브 시스템들 중에서 가장 중요한 것은 가상 메모리와 kmalloc 가변 길이 할당기, 슬랩할당기 이다. 
	* kmalloc
		* 서비스 요구시 페이지 전체를 할당해 주고, 그런 후에 더 작은 부분으로 쪼갠다. 
		* 커널은 kmalloc()서비스에 이용되는 페이지들을 리스트로 관리한다. 
		* 시스템 요구에 의해 할당된 메모리는 명시적으로 반납될 때까지는 계속되어 할당되어있고, 메모리가 부족하다고 해서 시스템은 이 영역을 재배치하거나 재사용 할 수 없다. 

	* 슬랩할당 
	
		![](https://image.slidesharecdn.com/random-150128200639-conversion-gate02/95/-50-638.jpg?cb=1422497393)
	
	
	
	

		* 커널 자료구조를 할당되는데 사용되며, 하나 이상의 연속된 물리 페이지로 구성되어 있다. 
		* 캐시는 하나의 슬랩으로 구성되어 있으며, 커널 자료구조마다 하나의 캐시가 존재한다. 
		* 커널 객체를 저장하기 위해 캐시를 사용하며, 캐시가 생성될 떄 많은 객체들이 생성된다. 
		* 리눅스에서 슬랩은 다음 3가지 상태중 한 상태에 있게 된다. 
			* FULL : 슬랩의 모든 객체가 사용중이라고 표시된다. 
			* EMPTY : 슬랩의 모든 객체가 가용이라고 표시된다. 
			* PARTIAL : 슬랩은 가용인 객체와 사용 중인 객체로 이루어져 있다. 

		*  커널이 프로세스 디스크립터를 나타내는 객체를 위한 메모리를 슬랩 할당기에서 요청하는 시나리오는 예를 들어 설명한다면, 슬랩 할당기는 처음 partial 슬랩에서 가용메모리를 검색하고 가용메모리가 없으면 empty 슬랩,  만약 할당할 수 없다면 물리적으로 연속된 페이지에서 새로운 슬랩이 할당된다. 

		
### 21.6.2 가상 메모리 
* 리눅스에서 가상 메모리 관리자는 영역들의 집합과 페이지들의 집합이라는 두 관점에서 프로세스 주소 공간을 관리한다. 
	* 주소공간의 첫번째 관점은 논리적인 관점이며, 주소 공간의 배치에 관하여 가상 메모리 시스템이 전달받은 지시사항들을 기술한다. 
		* 주소공간은 서로 겹쳐질 수 없는 영역들의 집합으로 구성되고, 각 영역은 연속적이고 페이지 위치에 정렬된 주소 공간의 부분 집합이다. 각 영역에는 영역의 특성을 정의하는 vm_ area _struct 자료구조에 의해 기술되고 영역에서의 프로세스가 가지는 읽기, 쓰기, 실행 허가권 등 영역에 연관된 파일에 관련된 정보가 특성에 해당된다. 
		* 각 주소 공간의 영역들은 균형 잡힌 이진트리로 연결되어 있어, 임의의 가상 주소에 해당되는 영역을 빠르게 찾을 수 있다. 
	* 커널은 두 번째로 각 주소 공간의 물리적인 면을 유지하는 데, 이러한 정보들은 프로세스들 하드웨어 페이지 테이블에 저장되어 있다. 
		* 각 페이지 테이블 엔트리들은 가상 메모리상의 각 페이지들이 현재 존재하는 위치정보를 결정한다. 
		* 주소공간의 물리적인 관점은 프로세스가 현재 페이지 테이블에 존재여부에 의해 호출되는 루틴들의 집합에 의해 관리되는데, 주소 공간에 각각 존재하는 vm_ area_struct들은 주어진 가상 메모리 영역을 위한 페이지 관리 기능을 구현하는 함수들의 테이블을 가리키는 필드를 포함한다. 

		
		
### 21.6.2.1 가상 메모리 영역 
* 백업 저장소 
	* 리눅스는 몇 가지 종류의 가상 메모리 영역을 구현하는데, 이 종류를 결정짓는 요소 중에 하나이다. 
	* 이 저장소는 영역의 페이지들이 어디에서 왔는지를 나타내는데, 대부분의 메모리 영역들은 파일로 부터 오든지 아무데서도 오지 않는(백업이 없는 경우) 둘 중에 하나이다. 
	* 후자의 경우 가장 간단한 타입으로 요구 제로 메모리를 나타낸다. 즉, 프로세스가 페이지를 읽으려고 할 떄 0으로 채워진 메모리를 받게된다. 
	* 전자의 경우 파일로 백업된 영역은 그 파일의 특정 부분을 가리킨다. 즉 프로세스가 페이지를 읽으려고 할 때  페이지 테이블에는 파일의 페이지 캐시에 존재하며, 파일 시스템을 통해 파일에 행해진 변경사항은 주소 공간에 맵핑한 프로세스들에게 곧바로 효럭을 나타낸다. 

* 가상 메모리 영역은 쓰기의 처리 방시게 의해 구분된다, 영역 공간 맵핑 방식은 크게 개인전용, 공유로 나눈다. 
	* 개인전용으로 맵핑된 영역에 쓰려면 페이저가 페이지 내용에 일어난 변화를 그 프로세스만 보게 하기 위해 쓰기-시 -복사 필요하다는 사실을 알 수 있다. 
	* 공유 영역에 쓸 때는 그 영역으로 맵핑되어졌던 객체 자체가 갱신됨으로써 그 객체를 맵핑 중인 다른 모든 프로세스들도 내용의 변화를 즉시 감지할 수 있다. 

### 21.6.2.2 가상 주소 공간의 일생 
* 커널의 새로운 가상 주소 공간을 만드는 경우는 2가지 상황밖에 없다. 
	* exec() 시스템 호출을 통해 새 프로그램의 '코드를 실행할 때'
		* 새 프로그램이 실행될 때, 프로세스는 새로운 가상 주소 공간을 할당 받는다. 이 공간을 가상 메모리 영역으로 채우는 일은 프로그램을 로드하는 루틴의 몫이다.   
	* fork() 시스템 호출을 통해 새 프로세스를 생성할 때   
		* 가상 주소공간을 완전히 복사하여 새 프로세스를 생성하게 된다. 커널은 부모 프로세스의 vm_ struct_area 디스크립터를 그대로 복사하고, 자식의 페이지 테이블을 새로 만들어 준다. 페이지 테이블도 그대로 복사하며, 이때 두 페이지 테이블을 가리키는 각 페이지 참조 카운트는 하나가 증가한다. 
		* 부모나 자식에 의해 페이지가 변경되지 않는 한, 두 프로세스는 동일한 페이지를 공유한다. 

		
### 21.6.2.3 스와핑과 페이징
* 가상 메모리 시스템에서 가장 중요한 작업 중에 하나는 이미 사용중인 물리 메모리 페이지들을 다른 목적으로 사용할 필요가 발생할 경우 물리메모리로부터 디스크로 재배치 시키는 작업이다. 
* 리눅스는 프로세스 전체를 스와핑하는 방식을 사용하지 않고 오로지 새로운 페이지 기법만을 사용한다. 
* 페이징 시스템은 두 개의 부분으로 나뉜다. 하나는 정책 알고리즘으로 어느 페이지를 디스크로 내보내야 할지와 언제 디스크로 내보내야 할지를 결정한다. 
* 또 하나는 페이징 기법으로 페이지들을 실제로 물리 메모리와 디스크로 움직이는 작업을 담당하고, 추후 이 페이지들이 필요하게 될 떄 물리 메모리로 옮겨오는 작업을 실행한다. 

* 리눅스의 페이지 아웃 정책은 표준 클럭의 변경된 버전을 사용한다. 리눅스에서는 다중_ 패스_ 클럭을 사용하는데, 모든 페이지들은 이 클럭이 지남에 따라 age를 가지고 있고, 이는 페이지의 최신 정도 또는 그 페이지가 얼마나 자주 사용되었느냐를 말해주는 척도이다. 
* 이러한 노화정도를 사용함으로써 LFU 정책을 기반으로 페이지 아웃 대상을 선택하게 한다. 
* 페이징 기법은 페이징을 전용의 스왑장치 및 파티션들이 하든지 아니면 일반 파일로 페이징 할수 있도록 지원한다. 
* 스왑하려면 스왑 장치에서 한 블록의 공간을 할당받아야 하는데, 이를 위해 블록 비트맵이 물리메모리에 상주하며, 스왑 공간 할당기는 next-fit 알고리즘을 사용하여 페이지를 연속된 디스크 블록에 써서 성능을 향상시킨다. 

### 21.6.2.4 커널 가상 메모리 
* 리눅스의 모든 프로세스의 가상 주소 공간 중 일정 부분을 커널 내부적으로 사용하기 위해 유보하는데, 이 공간의 위치는 아키텍처마다 다르다. 
* 이 커널 페이지들에 해당되는 페이지 테이블 엔트리들은 'protected'로 표시되어 처리기가 사용자 모드에서 실행 중일때 그 페이지들은 보이지도 않고 수정도 불가능하다. 
* 이 커널 가상 메모리 영역은 두 부분으로 나누어지고, 첫 부분은 정정 영역으로 시스템 내의 가용 물리 메모리 페이지에 각각에 대한 페이지 테이블 참조를 수록하고 있어 커널 코드가 실행될 때 물리주소와 가상주소로 쉽게 변환할 수 있다. 
* 나머지 영역은 특별한 목적을 위해 예약되어 있지 않다. 이 부분에 속해 있는 페이지 테이블 엔트리들은 필요 시 어떤 다른 메모리 영역도 가리킬 수 있도록 커널에 의해 변경 될 수 있다. 
* 커널은 프로세스들이 이들 가상 메모리를 사용할 수 있도록 vmalloc()과 vremap() 두 가지 설비를 제공한다. 

### 21.6.3 사용자 프로그램의 로딩과 실행 
* 리눅스 커널은 exec() 시스템 호출을 통해 사용자 프로그램을 실행한다. exec()을 호출하면 현존하는 프로세스로 하여금 문맥교환을 통해 새프로그램 코드가 실행될 수 있도록 한다. 
* 이 시스템 서비스는 exec()을 호출하는 프로세스가 새로 실행하려고 하는 프로그램 파일에 대한 접근권한을 가지고 있는지 확인하고, 커널은 로더 루틴을 호출한다.  로더는 프로그램을 가상 메모리로 맵핑하기 위한 최소한의 설정은 해줘야 한다. 
* 리눅스는 여로 로더 함수들의 테이블을 가지고 있고, exec() 시스템 호출이 실행되면 각 로더 함수는 지정된 파일을 로드할 수 있는 기회를 갖게된다. 

### 21.6.3.1 프로그램을 메모리로 맵핑 
* 리눅스에서는 이전 파일의 페이지들이 먼저 가상 메모리 영역으로 맵핑된 후 프로그램이 어떤 페이지를 접근하려 해서 페이지 폴트가 발생하면, 그때 페이지가 메모리로 로드된다. 
* 커널 이진 로더는 이러한 초기 메모리 매핑 셋업을 담당하며, ELF 포맷의 이진 파일은 한 개의 헤더와 여러 섹션들로 구성되는데, 이 헤더를 읽어서 나머지 파일의 섹션들을 분리된 가상 메모리 영역으로 맵핑한다. 

![](http://eresources.gitam.edu/comp/gvr(os)/13.6_files/image004.gif)


### 21.6.3.2 정적 연결과 동적 연결 
* 일단 프로그램이 로드되고 실행을 시작하면, 이진 파일의 필요한 내용들이 프로세스의 가상 주소 공간으로 적재되기 시작한다. 그러나 대부분의 프로그램은 시스템 라이브러리의 함수들을 호출할 필요가 있으므로 라이브러리 함수또한 적재되어야 한다. 
* 가장 간단한 형태는 프로그래머가 응용을 구축할 때 필요한 라이브러리 함수가 실행 가능한 이진 파일 형태로 삽입되는 정적 연결 
	* 하지만 프로그램마다 동일한 공통 라이브러리 함수들을 가지고 있어야 한다. 
	* 대신에 메모리와 디스크 사용의 관점에서 볼때 이 라이브러리들은 한 번만 로드되는 것이 훨씬 효율적이다,. 
* 리눅스는 특수한 링커 라이브러리를 통해 동적 연결을 사용저 모드에서 구현한다. 모든 동적으로 연결된 프로그램은 정적으로 연결된 조그만 함수를 가지며, 프로그램을 시작할ㄱ때 이 함수를 호출하고, 링크 라이브러리를 메모리로 맵핑하고 함수를 호출한다.  