#커널 입출력 서브시스템 (kernel I/O Subsystem)

### 13.4.1 입출력 스케줄링(I/O Scheduling) 
* 일련의 입출력 요구를 스케줄한다는 것은 그 요구들을 실행할 순서를 결정하는 것을 의미한다. 
* 스케줄링은 전반적인 시스템 성능을 향상시키고 프로세스들 사이에 공평성을 제공하고, 입출력 완료까지의 평균 대기시간을 줄 일 수 있다. 
![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/NCQ.svg/1200px-NCQ.svg.png)
























* 운영체제 개발자들은 각각의 장치마다 대기 큐를 유지함으로써 스케줄링을 구현한다. 또한 응용 프로그램이 봉쇄형 입출력 시스템 호출을 하면 그 입출력 요청은 해당 장치의 큐에 넣어진다. 입출력 스케줄러는 시스템의 성능과 각 응용에 대한 평균 응답 시간을 향상시키기 위해 큐 안의 순서를 재배치한다. 통상 OS는 공평하게 일을 처리하려고 하지만, 경우에 따라서는 시간이 급한 작업들을 빨리 처리해주기도 한다. 

* 커널이 비동기적 입출력을 제공한다면, 커널은 동시에 많은 입출력 오청을 추적해야 한다. 이를 위해 OS는 각 장치 상태  테이블에 대기큐를 연동하는데 여기에는 각 입출력에 대한 정보가 있다. ( 장치의 종류, 주소, 상태 - 동작하지 않음, 유휴, 동작 중 등이 있음) 만약 장치가 요청을 처리하느라 '동작 중' 상태이면 같은 장치에 대한 요청은 그 장치에 해당하는 테이블에 저장 될 것이다. 

* 입출력 서브시스템이 컴퓨터의 효율성을 증진시키는 방법 중에 하나는 입출력 스케줄링이고 또 다른 방법은 버퍼링, 스풀링 등 처럼 메모리나 디스크의 저장 장소를 이용는 방법이다. 

### 13.4.2 버퍼링 
* 버퍼 : 두 장치 사이 또는 장치와 응용 프로그램 사이에 데이터가 전송되는 동안 전송 데이터를 임시로 저장하는 메모리 영역 

* 버퍼링이 필요한 이유 
	1. 데이터의 생산자와 소비자 사이에 속도가 다른것에 대처하기 위함. 
	2. 데이터 전송 크기가 다른 장치들 사이의 완충을 제공하기 위함. - 네트워킹에서 많이 발생
	3. 응용 프로그램의 입출력 복사 시맨틱을 지원하기 위함 - P.634

### 13.4.3 캐싱 
* 캐시 : 자주 사용될 자료의 복사본을 저장하는 빠른 메모리 영역
* 버퍼는 그 데이터를 가지고 있는 유일한 장소인 반면에 캐시는 다른 곳에 이미 저장되어 있는 데이터의 복사본을 빠른 저장장소에 추가적으로 저장되어있다는 점이 차이점이다. 
* 캐싱과 버퍼는 다른 기능이지만 메모리의 한 영역에 두 가지 목적 모두를 위해 사용될 수 있다. 

### 13.4.4 스풀링 및 장치 예약 
* 스풀 : 인터리브하게 동작될 수 없는 프린터 같은 장치를 위해 출력 데이터를 보관하는 버퍼이다. 
* 프린터는 한번에 하나의 작업만 처리할 수 없기 때문에 여러 응용 프로그램이 번갈아가면서 출력시킬 수 없다. 
* 때문에 OS는 다른 프로그램의 출력과 섞이지 않게 데이터를 가로챔으로써 이 문제를 해결할 수 있다. 
* 몇몇 장치는 여러 응용의 프로그램 입출력 요구를 멀티플렉스 할 수 없기 때문에 스폴링을 통해 해결할 수 있는 방법이 있고 VMS처험 한 프로그램만이 장치를 독점적으로 사용하도록 허용하는 방법이 있다. 
* 이러한 시스템은 프로세스가 명시적으로 쉬고 있는 장치를 할당할 수 있고, 사용이 끝나면 명시적으로 반납할 수 있지만 교착상태를 해결하는 것은 응용 프로그램의 책임이 된다. 

### 13.4.5 에러 처리 
* 입출력 장치나 네트워크 전송은 일시적인 장애나 영구적인 원인 때문에 전송에 실패할 수 있지만 시스템의 전체의 마비로 나타나지 않는다. 
* OS는 일시적인 오류에는 재전송을 진행함으로서 오류를 극복할 수 있지만 장치가 영구적인 손상을 일으키면 극복하기 힘들다. 
* 일반적으로 입출력 시스템 호출은 성공/실패를 나타내는 한 비트를 반환하지만 UNIX OS는 errno라 하는 변수를 사용하여 100가지 종류의 에러를 구분하지만 운영체제에 의해 응용 프로그램에게 까지는 전달되지 않는다. 

### 13.4.6 입출력 보호 
* 사용자가 불법적인 입출력을 못하게 하기 위해 모든 입출력 명령을 특권 명령으로 정의한다. 따라서 사용자는 입출력 명령을 직접 실행할 수 없으며, 대신에 OS가 대신 실행하도록 시스템 호출을 실행한다. 
* 메모리 맵드 메모리 또는 입출력 포트 메모리의 위치는 메모리 보호 시스템에 의해 사용자로 부터 보호되어야 하나 무조건 사용자의 접근을 거부하면 안되기 때문에 잠금기법등을 제공해야 한다. 

### 13.4.7 커널 자료구조 
* 커널은 입출력 구성요소에 대한 상태 정보를 유지해야 한다. 따라서 오픈 파일 테이블과 구조와 같은 다양한 자료구조를 유지하며, 네트워크 연결, 문자 장치 통신, 그리고 다른 입출력 활동을 관리하기 위해 여러 비슷한 구조를 사용한다.
* UNIX는 파일 시스템 인터페이스를 사용하여 다양한 것에 접근할 수 있게 해준다. 
![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter13/13_12_UNIX_IO.jpg)
* 어떤 운영체제들은 객체지향 기법을 한 단계 확대하여 적용하기도 하는데 Windows NT에서는 입출력 서비스를 커널이 직접 해주지 않고 커널 밖의 입출력 관리자라는 프로그램에게 넘겨준다. 
![](https://regmedia.co.uk/2013/08/20/windows_nt_boot.jpg?x=1200&y=794)




### 13.4.8 커널 입출력 서브시스템 요약 
* 파일 및 장치의 이름 관리 
* 파일 및 장치에 대한 접근 제어 
* 작업 제어(예를 들어, 모뎀은 탐색할 수 없음) 
* 파일 시스템을 위한 공간 할당 
* 장치 할당 
* 버퍼링, 캐싱 및 스풀링 
* 입출력 스케줄링 
* 장치 상태 모니터링, 에러 처리 및 고장 복구 
* 장치 구동기 구성 및 초기화 
* 입출력 서브시스템의 상위 계층은 장치 구동기가 제공하는 공통적인 인터페이스를 통해 장치에 접근한다. 


### 13.5 입출력 요구를 하드웨어 연산으로 변환 
![](https://image.slidesharecdn.com/ch13-090420015741-phpapp02/95/chapter-13-io-systems-31-728.jpg?cb=1240192709)


### 13.6 STREAMS 
![](https://docs.oracle.com/cd/E18752_01/html/816-4855/figures/overvw1.fig30.png)

* 응용 프로그램으로 하여금 동적으로 드라이버 코드의 파이프라인을 조립할 수 있게 한다. 스트림은 디바이스 드라이버와 사용자 수준 프로세스 사이의 완전 양방향 연결을 말한다. 
* 스트림은 다음과 같이 구성되어 있다. 
	* 스트림 헤드 (사용자 프로세스와 상호 연동)
	* 드라이버 엔드 (디바이스를 제어) 
	* 스트림 모듈 (스트림 헤드와 드라이버 엔드 사이에 존재하는 0개 이상의 모듈) 
* 모듈은 스트림 처리 기능을 제공하며 ioctl() 시스템 호출을 사용하여 스트림에 푸시된다. 
* STREAMS 입출력은 사용자 프로세스가 스트림 헤드와 통신할 때를 제외하고 비동기이다. 즉 스트림에 쓰기를 할 때 사용자 프로세스는 스트림으로 부터 읽기를 할 때 데이터가 이용 가능할 때까지 봉쇄된다. 읽기도 마찬가지이다. 
* 드라이버 엔드도 읽기와 쓰기 큐를 가지고 있다는 점에서 스트림 헤드나 모듈과 비슷하지만 드라이버 엔드는 인터럽트에 반드시 응답해야 하며, 큐에 들어오는 모든 데이터를 처리해야 한다. 
* STREAMS를 사용함으로써 디바이스 드라이버와 네트워크 프로토콜을 작성할 때 모듈식이며 점진적인 접근을 위한 프레임 워크를 제공한다는 이점이 있다. 

### 13.7 성능 
* 입출력은 시스템 성능에 매우 중요한 요소이다. 하지만 입출력 과정들은 CPU나 메모리 버스등 장치들에게 부담이 많이 가는 일이기 때문에 이런 문제를 다루는건 컴퓨터 설계에 매우 중요한 부분을 이루고 있다. 
* 또한 현대 컴퓨터들은 초당 수천 번의 인터럽트를 처리할 수 있으나, 부담이 많이 가는 일이다. 
* 입출력의 효율을 높이기 위해서 다음과 같은 원칙들을 적용할 수 있다. 
	* 문맥 교환의 빈도를 줄인다. 
	* 메모리에서 장치와 응용 프로그램 사이에 데이터가 복사되는 횟수를 줄인다. 
	* 인터럽트 빈도를 줄인다. 이러기 위해서 한번 입출력할 때 많은 데이터를 전송하거나, 지능적인 제어기를 사용하는 방법 또는 폴링을 알맞게 사용하는 방법이 있다. 
	* DMA나 채널 등을 사용하면 CPU의 입출력 부담을 줄이고, 입출력과 주 연산이 될수록 많이 중첩되도록 도모한다.   