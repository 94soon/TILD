## Thrashing 
* 프로세스가 실제로 사용하는 프레임 수만큼의 프레임을 가지지 못해 계속적으로 페이지 부재가 발생함해 계속적으로 페이지 교체가 일어나는 현상 
* 프로세스 실헹 시간보다 페이지 교체 시간이 더 클 때 발생 
* 프로세스 실행보다 페이지 교체에 보내는 시간이 더 크기 때문 
![](http://cfile25.uf.tistory.com/image/185115444FD932471A569B) 

1. 다중 프로그래밍 정도가 높아짐에 따라 CPU 이용률이 높아진다. 
2. CPU이용률이 최대값에 도달했을때, 다중 프로그래밍 정도가 그 이상으로 커지만 쓰레싱이 일어나게 되고 CPU 이용률은 급격이 떨어진다. 
3. 운영체제는 CPU 이용률을 감시하면서, CPU 이용룰이 너무 낮아지면 새로운 프로세스를 시스템에 더 추가해서 다중 프로그램밍의 정도를 높인다. 
4. 이 때 전역 페이지 교체 알고리즘을 사용하여 어떤 프로레스의 페이지인지에 대한 고려 없이 교체를 수행한다. 

* 쓰레싱은 지역교환 알고리즘이나 우선순위 교환 알고리즘을 사용하여 제한할 수 있음 

* 작업 집합 모델 사용 
	* 운영체제는 각 프로세스의 작업집합을 감시하고 각 프로세스에게 작업집합의 크기에 맞는 충분한 프레임을 할당  
	* 이렇게 할당하고도 여분의 놀고 있는 프레임이 있다면 또 새로운 프로세스를 시작시킬 수 있다. 
	* 실행중인 프로세스의 수가 너무 많이지면 운영체제는 프로세스들 중 하나를 선택하여 그 프로세스의 페이지를 빼앗거나 연기시켜 그 프레임을 다른 프포세스에게 할당한다. 
	* 중단된 프로세스는 후에 다시 실행이 재개된다. 이 방법은 쓰레싱을 방지하고 CPU의 이용률을 최적화 한다. 
	* 작업 집합 모델의 어려운 점은 작업 집합을 추적하는 일이다. 
	* 작업 집합은 메모리 참조마다 한쪽에서 새로운 페이지들이 추가 되고 다른 한쪽에서는 오랜된 참조 페이지로 부터 제외된다. 
	* 이를 효율적으로 관리하기 위해 일정 간격 타이머 인터럽트와 참조 비트를 쓰면 어느정도 유사한 모델을 근사화 할 수 있다. 
	* 이 방법 또한 어느 페이지가 사용되었는지 근사치를 알 뿐 정확하지 않다. 따라서 과거 기억 비트수를 늘리고 타이머 인터럽트 빈도를 높이면 불확실성을 줄일 수 있지만 자주 발생하는 인터럽트의 처리의 오버해드는 증가한다. (성능이 떨어진다.) 
	![](http://2.bp.blogspot.com/-GKHoa0T-3kA/T5FmYltx79I/AAAAAAAAI-c/W7FWCAIvKGI/s1600/사용자+지정+31.jpg)
	
* 페이지 부재율 조절 
	* 페이지 부재율이 너무 높으면 그 프로세스가 더 많은 프레임을 필요로 하는 것이고 너무 낮으면 프로세스가 너무 많은 프레임을 갖고 있다는 것 
	* 페이지 부재율의 상한과 하안을 두고 상한을 넘으면 프레임을 더 할당하고 하한보다 낮으면 프레임을 회수 
	* 페이지 부재율이 증가되고 유효 프레임이 없으면 한 프로세스를 선택하여 중지 
	![](http://mblogthumb2.phinf.naver.net/20130704_1/jevida_1372916193642wF4vg_PNG/2.png?type=w2)













## 메모리 사상 파일 
* 프로세스에서 특정 파일에 접근하여 데이터를 읽고 쓴다고 할 때, 시스템 호출로 하기에는 많은 시간이 든다. 그래서 해당 파일을 메모리에 올려 빠르게 접근하여 사용한다. 이러한 방식을 메모리 사상이라고 한다. 해당 방식을 사용하면 공유 메모리를 이용하여 파일을 여러 프로세스가 공유할 수 있다.
	* 첫 번째 접근은 일반적인 요구 페이징 과정에 따라 페이지 부재 발생 
		* 페이지 크기 만큼의 해당부분이 파일 시스템으로 부터 메모리 페이지로 읽어들어온다. 
		* 이후의 파일 읽기/쓰기는 다른 메모리 엑세스와 마찬가지로 취급된다. 
	* 파일 접근과 사용을 단순하게 한다. 
	* 여러 프로세스들이 자료 공유를 위해 파일을 공유하기 쉽다.  
![](http://cfile2.uf.tistory.com/image/271729365751267A077EAB)


### Win32 API에서 공유 메모리 
![](https://mblogthumb-phinf.pstatic.net/20151118_68/93immm_14477892731808xN8D_JPEG/a0051744_4e12f49c0db65.jpg?type=w2)

* 먼저 사상될 파일에 대한 사상을 생성하고, 사상된 파일의 프로세스가 주소공간상의 뷰를 만든다. 
* 다른 프로세스는 파일은 연 뒤 사상된 파일의 뷰를 가상 주소 공간상에 생성한다. 
* 사상된 파일은 프로세스들 간의 통신을 위한 공유 메모리 객체를 나타난다. 

![](https://mblogthumb-phinf.pstatic.net/20151118_87/93immm_1447789919114cA3SR_JPEG/5678.jpg?type=w2)

* 프로세스는 어떤 방식으로 공유데이터에 접근하는가? 
	* 일반적으로 페이지 디렉토리 -> 페이지 테이블 -> 목적지 테이블 
	* 공유데이터의 경우 페이지 디렉토리 -> 페이지 테이블 -> 프로토차입 페이지엔트리 -> 목적지 페이지 
	* https://msdn.microsoft.com/en-us/library/ms810613.aspx 

	
### 메모리 사상 I/O 
* 입출력의 경우 각 I/O컨트롤러는 명령어와 전송할 데이터를 담기 위한 레지스터들을 포함하고 있다. 
* 이러한 레지스터와 시스템 메모리간의 데이터 전송을 위해서 특별한 I/O 명령어가 사용되는데, 많은 컴퓨터 구조는 메모리 사상 I/O기능을 제공한다. 
* 특정 메모리 영역이 장치 레지스터들을 사상할 수 있도록 유보하고, 이 주소에 대한 읽기, 쓰기 작업은 장치 레지스터로의 데이터 전송으로 처리한다. 
	*  마이크로프로세서(CPU)가 입출력 장치를 액세스할 때, 입출력과 메모리의 주소 공간을 분리하지 않고 하나의 메모리 공간에 취급하여 배치하는 방식이다. 따라서 전체 메모리의 주소공간에 입출력 장치의 메모리나 레지스터를 메모리로 취급하여 전체 메모리의 일부분으로 특정영역에 할당하여 배치하는 방식이다. 입출력 장치의 메모리 주소가 나뉘어 있지 않기 때문에 액세스할 때는 메모리와 같은 주소공간이므로 같은 기계어 코드로 수행한다. 입출력 맵 입출력의 주소공간이 나뉘어 있어서 분리되어 있는 반면 메모리 맵 입출력은 메모리의 한 부분일 뿐이다. 
* 이러한 방법은 응답시간이 매우 빠른 그래픽카드나, 모뎀이나 프린터를 연결하는 직렬/병렬 포트에도 편리하다.  


### 커널 메모리 할당 
* 커널 메모리는 보통 사용자 모드 프로세스에게 할당해 주기 위한 페이지 리스트와는 별도의 메모리 풀에서 할당받는다. 이렇게 하는 이유는 다음과 같다. 
	1. 커널은 다양한 크기의 자료 구조를 위한 메모리를 할당받는다. 이 자료 구조들은 페이지 크기보다 작은 크기를 갖기도 한다. 결과적으로 커널은 메모리 사용을 절제해야 하며, 단편화에 의한 낭비를 최소화하고자 한다. 많은 운영체제들이 커널코드나 데이터를 페이징하지 않기 때문에 특히 중요하다. 
	2. 사용자 모드 프로세스에 할당되는 페이지들은 물리 메모리상에서 굳이 연속될 필요는 없다. 그러나 가상 메모리 인터페이스를 통하지 않고 물리 메모리에 직접 접근하는 특정 하드웨어 장치는 물리적으로 연속적인 메모리를 필요로 하는 경우가 있다. 

--
* 버디 시스템 
	* 버디 시스템은 물리적으로 연속된 페이지들로 이루어진 고정된 크기의 세그먼트로부터 메모리를 할당한다. 메모리는 2의 거듭제곱 단위로 할당된다. 분활된 세그먼트를 버디라고 하며 연속된 버디들은 쉽게 합병이 가능하다. 단점은 어정쩡하게 요구되면 내부 단편화가 발생한다

	![](http://cfile4.uf.tistory.com/image/216A483C575129970C96BC)

* 슬랩 할당 
	*  Slab이란 하나 또는 그 이상의 연속된 페이지의 구성이다. 캐시는 하나 또는 그이상의 슬랩으로 구성된다. 캐시는 커널 자료구조 마다 하나의 캐시가 존재한다. 캐시 내의 자료 구조 객체 수는 캐시에 들어가 있는 Slab의 크기에 따라 달라진다. 슬랩의 장점으로는 내부 단편화가 없으며 메모리 요청이 빠르게 처리된다.
	
	![](http://cfile3.uf.tistory.com/image/254F4F4A55D55452170A62)
	
	
* 딘편화에 의한 낭비가 없는 이유 
	* 각 고유한 커널 자료구조가 연관된 캐시를 가지고, 각 캐시는 하나 이상의 슬랩으로 구성되며, 이 슬랩은 객체의 크기로 나눠지기 때문에 단편화 문제가 발생하지 않는다 즉 메모리를 요구할 때마다 슬랩 할당기는 정확히 필요한 만큼의 메모리만을 할당한다. 

* 메모리 요청이 빠르게 처리되는 이유 
	* 슬랩 할당기는 객체의 할당과 래제가 빈번한 경우 메모리를 관리하는데 효휼적이다. 커널로 부터 오는 요청은 대부분 이런 특징을 보인다. 
	* 메모리 할당과 해제는 상당한 시간이 소요된다. 그러나 객체들은 미리 생성되어 있고, 따라서 캐시에서 쉽게 할당이 가능하고 커널이 특정 객체를 다 사용하고 해제하면 free로 표시된 상태로 캐시로 반환되어 다음 요구 시 즉시 할당할 수 있다.   

### 기타 고려사항 
* 프리페이징 
	* 프로세스가 시작될 때 많은 페이지 부재가 발생한다. 과도한 페이지 부재를 방지하기 위한 방법으로 모든 페이지나 어느 정도의 페이지를 미리 메모리에 올리는 것이다.

* 페이지 크기 
	* 페이지 크기와 관련된 것은 테이블의 크기이다. 테이블에 들어가는 페이지의 개수가 고정일때 페이지의 크기가 작아지면 테이블의 크기는 작아진다. 필요 데이터에 대한 정밀도는 높아지나 데이터의 양이 적어 빈번히 페이지를 교체해야한다. 
페이지의 크기가 커지면 페이지 교체율은 낮아지고 입출력 시간이 줄어든다. 그러나 페이지의 내부 단편화가 발생할 수가 있다. 

* TLB 범위 
	* TLB Reach란 TLB로 부터 액세스할 수 있는 메모리 공간의 크기이다. TLB는 8장에서 설명하였으며 MMU안에 있는 특수 소형의 캐시이며 associative memory로 구성된다. 또한 메모리에 있는 page table를 통해 해당 페이지를 찾아가는 것보다 효율적으로 접근할 수 있다. 
TLB Reach  = (TBL에 들어갈 수 있는 페이지 개수) x (page size)
여러 크기의 페이지를 수용하려면 TLB는 운영체제가 관리를 해야한다. 그러면 소프트웨어 적인 오버헤드가 발생하는데 이는 hit ratio와 TLB reach의 향상으로 상쇄될 수 있다.

* 역페페이지 테이블 
	* 테이블은 가상 주소에 대해 오름차순으로 정렬되어 있으며 운영체제는 이 테이블에서 원하는 페이지가 어느 곳에 있는지계산하여 접근한다. 이러한 기법의 단점으로는 페이지 테이블의 크기이다.이러한 문제를 해결하기 위해 역 페이지 테이블(inverted page table)방법을사용한다.
 
	* 역 페이지 테이블에서는 메모리 프레임마다 한 항목씩을 할당한다. 각항목은 프레임에 올라와 있는 페이지 주소, 그리고 그 페이지를 소유하고 있는 프로세스ID를 표시하고 있다. 이렇게 되면 시스템에는 단 하나의 페이지 테이블만이존재하게 되고 테이블 내 각 항목은 메모리 한 프레임씩을 가리키게 된다. 

* 역 페이지 테이블 구성 순서
	1. 가상 주소는 process-id,page-number, offset 세 가지 항목으로 구성
	2. 각 역 페이지 테이블의 항목은 process-id, page-number의 쌍으로 이루어져 있으며process-id는 주소 공간 ID의 역할을 한다.
	3. 메모리 참조가 발생하면 process-id,page-number의 쌍으로 이루어진 가상 주소의 일부 메모리 서브시스템에 전달 된다.
	4. 역 페이지 테이블에서 일치하는 것이 있는지 검색 한다.
	5. 일치하는 것이 i 번째 항목에서 발견되면 물리주소는 i, offset가 되고 일치 하는 것이 없으면 잘못된 메모리로 간주 한다.
 
* 장점으로는 논리 페이지마다 항목을 가지는 대신 물리 프레임에 대응되는 항목만 테이블에 저장하기 때문에 메모리에서훨씬 작은 공간을 점유 한다.
* 단점으로는 역 페이지 테이블은 주소 변환 시간이 더 오래 걸릴 수 있으며 프레임에 따라 저장되어있어 탐색은 비효율적이다.
* 페이지 테이블을 해싱이 느린 경우 최근에 사용된 항목을 TLB 연관메모리 레지스터에 저장시켜 다음 참조 시 레지스터만 검사하면서 시간을 단축한다. 
* 역 페이지 테이블을 사용하는 시스템에서 메모리의 공유는 어렵다. 페이지테이블이 공유된 물리 주소에 대해 하나의 가상 주소를 매핑하기 때문에 매핑되지 못한 다른 가상 주소가 공유된 영역을 참조하게 되면 페이지 폴트(page fault)가 발생 한다.

* 프로그램 구조 
	![](http://cfile10.uf.tistory.com/image/2114143A575133A9069629)
	* 어느 쪽이 성능이 더 좋은가? P.448

* 입출력 상호 잠금 

![](http://slideplayer.com/4967787/16/images/71/Other+Issues+–+I%2FO+interlock.jpg)

* 어떤 프로세스가 I/O큐에 있는 동안 I/O버퍼에 해당되는 페이지가 다른 프로세스에 의해 교체됨 
	* 해결방안 
		1. 시용자 공간에는 입출력을 하지 않는다. 
			* 실제 입출력은 항상 시스템 메모리와 입출력장치 사이에서만 행해지고 그 후 시스템 메모리와 사용자 메모리 사이에서 테이터가 복사된다. 
			* 테이프에 어떤 블록을 쓰고 싶으면 먼저 시스템 메모리로 복사하고 거기서 테이프에 쓰기 작업을 실행하는 방법으로 이 추가복사는 허용할 수 없는 큰 오버해드를 유발시킬 수 있다.
		2. 페이지를 잠금한다. 
			* 잠금비트를 각 프레임마다 두고 만약 프레임이 잠금되면 그것은 교체대상에서 제외된다. 
			* 이러한 방식에서는 테이프 블록을 쓰기 위해서는 해당 블록을 담고있는 페이지를 참가야 하며, 이후 시스템은 예전처럼 실행을 계속할 수 있다. 입출력이 완료되면 그 페이지의 잠금을 해제된다.

			
### 운영체제의 예 
![](https://cdn.namuwikiusercontent.com/b3/b3ab02f986edcc27a386ef9303228003d2ab8d719d537c1490b899bc992c7dbc.gif?e=1501484880&k=AP6-6t7ddAW7Fin_9YS6fQ)
	

* 윈도우XP는 클러스터링 방식을 결합한 요구 페이징 가상 메모리를 구현한다. 
* 클러스터링에서는 페이지 부제가 발생하면 그 페이지뿐만 아니라 그 페이지 다음에 위치한 여러 페이지들도 함께 가져온다. 
* 프로세스는 처음 생성될 때 작업 집합의 상한과 하안이 결정되고, 시스템 전체적으로 가용 공간이 임계치보다 낮아지면 시스템은 작업 집합 조절 전술을 써서 임계치 이상의 가용공간을 확보한다. 


![](https://www.oracle.com/us/assets/cw20-boxshot-solaris11-2717543.jpg)

* 스레드가 페이지 부재를 일으키면 커널은 자신이 관리하고 있는 가용 페이지 리스트로부터 한 페이지를 확보에 할당해 준다. 
* 운영체제 커널은 항상 충분한 가용 공간을 확보해야 한다.   